dnl Process this file with autoconf to produce a configure script.
dnl Written in 2002 by Christian Bauer

AC_INIT(main_unix.cpp)
AC_PREREQ(2.12)
AC_CONFIG_HEADER(config.h)

dnl Canonical system information.
AC_CANONICAL_HOST
AC_CANONICAL_TARGET

dnl Options.
AC_ARG_ENABLE(jit,          [  --enable-jit            enable JIT compiler [default=yes]], [WANT_JIT=$enableval], [WANT_JIT=yes])
AC_ARG_ENABLE(ppc-emulator, [  --enable-ppc-emulator   use the selected PowerPC emulator [default=auto]], [WANT_EMULATED_PPC=$enableval], [WANT_EMULATED_PPC=auto])
AC_ARG_ENABLE(xf86-dga,     [  --enable-xf86-dga       use the XFree86 DGA extension [default=yes]], [WANT_XF86_DGA=$enableval], [WANT_XF86_DGA=yes])
AC_ARG_ENABLE(xf86-vidmode, [  --enable-xf86-vidmode   use the XFree86 VidMode extension [default=no]], [WANT_XF86_VIDMODE=$enableval], [WANT_XF86_VIDMODE=no])
AC_ARG_ENABLE(vosf,         [  --enable-vosf           enable video on SEGV signals [default=yes]], [WANT_VOSF=$enableval], [WANT_VOSF=yes])
AC_ARG_WITH(esd,            [  --with-esd              support ESD for sound under Linux/FreeBSD [default=yes]], [WANT_ESD=$withval], [WANT_ESD=yes])
AC_ARG_WITH(gtk,            [  --with-gtk              use GTK user interface [default=yes]], [WANT_GTK=$withval], [WANT_GTK=yes])
AC_ARG_WITH(mon,            [  --with-mon              use mon as debugger [default=yes]], [WANT_MON=$withval], [WANT_MON=yes])
AC_ARG_WITH(dgcc,           [  --with-dgcc=COMPILER    use C++ COMPILER to compile synthetic opcodes], [DYNGEN_CC=$withval])

dnl SDL options.
AC_ARG_ENABLE(sdl-static,   [  --enable-sdl-static     use SDL static libraries for linking [default=no]], [WANT_SDL_STATIC=$enableval], [WANT_SDL_STATIC=no])
AC_ARG_ENABLE(sdl-video,    [  --enable-sdl-video      use SDL for video graphics [default=no]], [WANT_SDL_VIDEO=$enableval], [WANT_SDL_VIDEO=no])

dnl Checks for programs.
AC_PROG_CC
AC_PROG_CPP
AC_PROG_CXX
AC_PROG_MAKE_SET
AC_PROG_INSTALL

dnl Check for PowerPC target CPU.
HAVE_PPC=no
AC_MSG_CHECKING(for PowerPC target CPU)
AC_EGREP_CPP(yes,
[
#ifdef __powerpc__
  yes
#endif
#ifdef __ppc__
  yes
#endif
], [AC_MSG_RESULT(yes); HAVE_PPC=yes], AC_MSG_RESULT(no))

dnl We use native CPU if possible.
EMULATED_PPC=yes
case $WANT_EMULATED_PPC in
  auto) [[ "x$HAVE_PPC" = "xyes" ]] && EMULATED_PPC=no;;
  no)   EMULATED_PPC=no;;
esac
if [[ "x$EMULATED_PPC" = "xyes" ]]; then
  AC_DEFINE(EMULATED_PPC)
fi

dnl We use mon if possible.
MONSRCS=
case "x$WANT_MON" in
x/* | x.*)
  mon_srcdir=$WANT_MON
  WANT_MON=yes
  ;;
xyes)
  mon_srcdir=../../../mon/src
  ;;
esac
if [[ "x$WANT_MON" = "xyes" ]]; then
  AC_MSG_CHECKING(for mon)
  if grep mon_init $mon_srcdir/mon.h >/dev/null 2>/dev/null; then
    AC_MSG_RESULT(yes)
    AC_DEFINE(ENABLE_MON)
    MONSRCS="$mon_srcdir/mon.cpp $mon_srcdir/mon_6502.cpp $mon_srcdir/mon_z80.cpp $mon_srcdir/mon_cmd.cpp $mon_srcdir/mon_lowmem.cpp $mon_srcdir/mon_disass.cpp $mon_srcdir/mon_ppc.cpp $mon_srcdir/disass/floatformat.c $mon_srcdir/disass/i386-dis.c $mon_srcdir/disass/m68k-dis.c $mon_srcdir/disass/m68k-opc.c"
    CXXFLAGS="$CXXFLAGS -I$mon_srcdir -I$mon_srcdir/disass"
    AC_CHECK_LIB(ncurses, tgetent, ,
      AC_CHECK_LIB(termcap, tgetent, ,
        AC_CHECK_LIB(termlib, tgetent, ,
          AC_CHECK_LIB(terminfo, tgetent, ,
            AC_CHECK_LIB(Hcurses, tgetent, ,
              AC_CHECK_LIB(curses, tgetent))))))
    AC_CHECK_LIB(readline, readline)
    AC_CHECK_HEADERS(readline.h history.h readline/readline.h readline/history.h)
  else
    AC_MSG_RESULT(no)
    AC_MSG_WARN([Could not find mon, ignoring --with-mon.])
    WANT_MON=no
  fi
fi

dnl Checks for libraries.
AC_CHECK_LIB(posix4, sem_init)

dnl Do we need SDL?
WANT_SDL=no
SDL_SUPPORT="none"
if [[ "x$WANT_SDL_VIDEO" = "xyes" ]]; then
  WANT_SDL=yes
  WANT_XF86_DGA=no
  WANT_XF86_VIDMODE=no
  WANT_FBDEV_DGA=no
  SDL_SUPPORT="video"
fi
if [[ "x$WANT_SDL" = "xyes" ]]; then
  AC_PATH_PROG(sdl_config, "sdl-config")
  if [[ -n "$sdl_config" ]]; then
    sdl_cflags=`$sdl_config --cflags`
    if [[ "x$WANT_SDL_STATIC" = "xyes" ]]; then
      sdl_libs=`$sdl_config --static-libs`
    else
      sdl_libs=`$sdl_config --libs`
    fi
    CFLAGS="$CFLAGS $sdl_cflags"
    CXXFLAGS="$CXXFLAGS $sdl_cflags"
    LIBS="$LIBS $sdl_libs"
  else
    WANT_SDL=no
  fi
fi

dnl We need X11, if not using SDL.
if [[ "x$WANT_SDL" = "xno" ]]; then
  AC_PATH_XTRA
  if [[ "x$no_x" = "xyes" ]]; then
    AC_MSG_ERROR([You need X11 to run SheepShaver.])
  fi
  CFLAGS="$CFLAGS $X_CFLAGS"
  CXXFLAGS="$CXXFLAGS $X_CFLAGS"
  LIBS="$LIBS $X_PRE_LIBS $X_LIBS -lX11 -lXext $X_EXTRA_LIBS"
fi

dnl We need pthreads on non-PowerPC systems. Try libpthread first, then libc_r (FreeBSD), then PTL.
HAVE_PTHREADS=yes
case $EMULATED_PPC:$target_os in
no:linux*)
  dnl We do have our own pthread_cancel() implementation
  AC_DEFINE(HAVE_PTHREAD_CANCEL, 1, [Define if you have the pthread_cancel function.])
  ;;
*:*)
  AC_CHECK_LIB(pthread, pthread_create, , [
    AC_CHECK_LIB(c_r, pthread_create, , [
      AC_CHECK_LIB(PTL, pthread_create, , [
        AC_MSG_ERROR([You need pthreads to run Basilisk II.])
      ])
    ])
  ])
  AC_CHECK_FUNCS(pthread_cancel)
  AC_CHECK_FUNCS(pthread_mutexattr_setprotocol)
  AC_CHECK_FUNCS(pthread_mutexattr_settype)
  AC_CHECK_FUNCS(pthread_mutexattr_setpshared)
  if [[ "x$HAVE_PTHREADS" = "xyes" ]]; then
    AC_DEFINE(HAVE_PTHREADS, 1, [Define if pthreads are available.])
  fi
  dnl If POSIX.4 semaphores are not available, we emulate them with pthread mutexes.
  SEMSRC=
  AC_CHECK_FUNCS(sem_init, , [
  if test "x$HAVE_PTHREADS" = "xyes"; then
    SEMSRC=posix_sem.cpp
  fi
  ])
  ;;
esac

dnl We use XFree86 DGA if possible.
if [[ "x$WANT_XF86_DGA" = "xyes" ]]; then
  AC_CHECK_LIB(Xxf86dga, XF86DGAQueryExtension, [
    AC_DEFINE(ENABLE_XF86_DGA)
    LIBS="$LIBS -lXxf86dga"
  ], [
    AC_MSG_WARN([Could not find XFree86 DGA extension, ignoring --enable-xf86-dga.])
    WANT_XF86_DGA=no
  ])
fi

dnl We use XFree86 VidMode if possible.
if [[ "x$WANT_XF86_VIDMODE" = "xyes" ]]; then
  AC_CHECK_LIB(Xxf86vm, XF86VidModeQueryExtension, [
    AC_DEFINE(ENABLE_XF86_VIDMODE)
    LIBS="$LIBS -lXxf86vm"
  ], [
    AC_MSG_WARN([Could not find XFree86 VidMode extension, ignoring --enable-xf86-vidmode.])
    WANT_XF86_VIDMODE=no
  ])
fi

dnl We use GTK+ if possible.
UISRCS=../dummy/prefs_editor_dummy.cpp
if [[ "x$WANT_GTK" = "xyes" ]]; then
  AM_PATH_GTK(1.2.0, [
    AC_DEFINE(ENABLE_GTK)
    CFLAGS="$CFLAGS $GTK_CFLAGS"
    CXXFLAGS="$CXXFLAGS $GTK_CFLAGS"
    LIBS="$LIBS $GTK_LIBS"
    UISRCS=prefs_editor_gtk.cpp
  ], [
    AC_MSG_WARN([Could not find GTK+, disabling user interface.])
    WANT_GTK=no
  ])
fi

dnl We use ESD if possible.
if [[ "x$WANT_ESD" = "xyes" ]]; then
  AM_PATH_ESD(0.2.8, [
    AC_DEFINE(ENABLE_ESD)
    CFLAGS="$CFLAGS $ESD_CFLAGS"
    CXXFLAGS="$CXXFLAGS $ESD_CFLAGS"
    LIBS="$LIBS $ESD_LIBS"
  ], [
    AC_MSG_WARN([Could not find ESD, disabling ESD support.])
    WANT_ESD=no
  ])
fi

dnl Checks for header files.
AC_HEADER_STDC
AC_HEADER_SYS_WAIT
AC_CHECK_HEADERS(mach/vm_map.h mach/mach_init.h sys/mman.h)
AC_CHECK_HEADERS(sys/time.h sys/times.h)
AC_CHECK_HEADERS(unistd.h fcntl.h byteswap.h)
AC_CHECK_HEADERS(linux/if.h linux/if_tun.h net/if.h net/if_tun.h)

dnl Checks for typedefs, structures, and compiler characteristics.
AC_C_BIGENDIAN
AC_C_CONST
AC_C_INLINE
AC_CHECK_SIZEOF(short, 2)
AC_CHECK_SIZEOF(int, 4)
AC_CHECK_SIZEOF(long, 4)
AC_CHECK_SIZEOF(long long, 8)
AC_CHECK_SIZEOF(float, 4)
AC_CHECK_SIZEOF(double, 8)
AC_CHECK_SIZEOF(void *, 4)
AC_TYPE_OFF_T
AC_CHECK_TYPE(loff_t, off_t)
AC_TYPE_SIZE_T
AC_TYPE_SIGNAL
AC_HEADER_TIME
AC_STRUCT_TM

dnl Check whether struct sigaction has sa_restorer member.
AC_CACHE_CHECK([whether struct sigaction has sa_restorer],
  ac_cv_signal_sa_restorer, [
  AC_TRY_COMPILE([
    #include <signal.h>
  ], [struct sigaction sa; sa.sa_restorer = 0;],
  ac_cv_signal_sa_restorer=yes, ac_cv_signal_sa_restorer=no,
  dnl When cross-compiling, do not assume anything.
  ac_cv_signal_sa_restorer=no
  )
])
if [[ "x$ac_cv_signal_sa_restorer" = "xyes" ]]; then
  AC_DEFINE(HAVE_SIGNAL_SA_RESTORER)
fi

dnl Checks for library functions.
AC_CHECK_FUNCS(strdup strlcpy cfmakeraw)
AC_CHECK_FUNCS(nanosleep)
AC_CHECK_FUNCS(sigaction signal)
AC_CHECK_FUNCS(mmap mprotect munmap)
AC_CHECK_FUNCS(vm_allocate vm_deallocate vm_protect)
AC_CHECK_FUNCS(posix_memalign memalign valloc)

dnl Darwin seems to define mach_task_self() instead of task_self().
AC_CHECK_FUNCS(mach_task_self task_self)

dnl We need clock_gettime() for better performance but it may drag
dnl libpthread in, which we don't want for native ppc mode
case $EMULATED_PPC:$target_os in
no:linux*)
  ;;
*:*)
  AC_SEARCH_LIBS(clock_gettime, [rt posix4])
  AC_CHECK_FUNCS(clock_gettime)
  ;;
esac

dnl Select system-dependant sources.
SERIALSRC=serial_unix.cpp
ETHERSRC=../dummy/ether_dummy.cpp
SCSISRC=../dummy/scsi_dummy.cpp
AUDIOSRC=../dummy/audio_dummy.cpp
EXTRASYSSRCS=
case "$target_os" in
linux*)
  ETHERSRC=Linux/ether_linux.cpp
  AUDIOSRC=audio_oss_esd.cpp
  SCSISRC=Linux/scsi_linux.cpp
  if [[ "x$EMULATED_PPC" = "xno" ]]; then
    EXTRASYSSRCS="Linux/paranoia.cpp Linux/sheepthreads.c Linux/asm_linux.S"
  fi
  ;;
darwin*)
  if [[ "x$EMULATED_PPC" = "xno" ]]; then
    EXTRASYSSRCS="Darwin/paranoia.cpp Linux/asm_linux.S"
  fi
  ;;
esac

dnl SDL overrides
if [[ "x$WANT_SDL" = "xyes" ]]; then
  AC_DEFINE(USE_SDL, 1, [Define to enble SDL support])
fi
if [[ "x$WANT_SDL_VIDEO" = "xyes" ]]; then
  VIDEOSRCS="../SDL/video_sdl.cpp ../dummy/clip_dummy.cpp"
  AC_DEFINE(USE_SDL_VIDEO, 1, [Define to enable SDL video graphics support])
else
  VIDEOSRCS="video_x.cpp clip_unix.cpp"
fi

SYSSRCS="$VIDEOSRCS $SERIALSRC $ETHERSRC $SCSISRC $AUDIOSRC $SEMSRC $UISRCS $MONSRCS $EXTRASYSSRCS"

dnl Define a macro that translates a yesno-variable into a C macro definition
dnl to be put into the config.h file
dnl $1 -- the macro to define
dnl $2 -- the value to translate
dnl $3 -- template name
AC_DEFUN(AC_TRANSLATE_DEFINE, [
    if [[ "x$2" = "xyes" -o "x$2" = "xguessing yes" ]]; then
        AC_DEFINE($1, 1, $3)
    fi
])

dnl Check that the host supports TUN/TAP devices
AC_CACHE_CHECK([whether TUN/TAP is supported],
  ac_cv_tun_tap_support, [
  AC_TRY_COMPILE([
    #if defined(HAVE_LINUX_IF_H) && defined(HAVE_LINUX_IF_TUN_H)
    #include <linux/if.h>
    #include <linux/if_tun.h>
    #endif
    #if defined(HAVE_NET_IF_H) && defined(HAVE_NET_IF_TUN_H)
    #include <net/if.h>
    #include <net/if_tun.h>
    #endif
  ], [
    struct ifreq ifr;
    memset(&ifr, 0, sizeof(ifr));
    ifr.ifr_flags = IFF_TAP | IFF_NO_PI;
  ],
  ac_cv_tun_tap_support=yes, ac_cv_tun_tap_support=no
  )
])
AC_TRANSLATE_DEFINE(ENABLE_TUNTAP, "$ac_cv_tun_tap_support",
  [Define if your system supports TUN/TAP devices.])

dnl Various checks if the system supports vm_allocate() and the like functions.
have_mach_vm=no
if [[ "x$ac_cv_func_vm_allocate" = "xyes" -a "x$ac_cv_func_vm_deallocate" = "xyes" -a \
      "x$ac_cv_func_vm_protect" = "xyes" ]]; then
  have_mach_vm=yes
fi
AC_TRANSLATE_DEFINE(HAVE_MACH_VM, "$have_mach_vm",
  [Define if your system has a working vm_allocate()-based memory allocator.])

dnl Check that vm_allocate(), vm_protect() work
if [[ "x$have_mach_vm" = "xyes" ]]; then

AC_CACHE_CHECK([whether vm_protect works],
  ac_cv_vm_protect_works, [
  AC_LANG_SAVE
  AC_LANG_CPLUSPLUS
  ac_cv_vm_protect_works=yes
  dnl First the tests that should segfault
  for test_def in NONE_READ NONE_WRITE READ_WRITE; do
    AC_TRY_RUN([
      #define CONFIGURE_TEST_VM_MAP
      #define TEST_VM_PROT_$test_def
      #include "vm_alloc.cpp"
    ], ac_cv_vm_protect_works=no, rm -f core,
    dnl When cross-compiling, do not assume anything
    ac_cv_vm_protect_works="guessing no"
    )
  done
  AC_TRY_RUN([
    #define CONFIGURE_TEST_VM_MAP
    #define TEST_VM_PROT_RDWR_WRITE
    #include "vm_alloc.cpp"
  ], , ac_cv_vm_protect_works=no,
  dnl When cross-compiling, do not assume anything
  ac_cv_vm_protect_works="guessing no"
  )
  AC_LANG_RESTORE
  ]
)

dnl Remove support for vm_allocate() if vm_protect() does not work
if [[ "x$have_mach_vm" = "xyes" ]]; then
  case $ac_cv_vm_protect_works in
    *yes) have_mach_vm=yes;;
    *no) have_mach_vm=no;;
  esac
fi
AC_TRANSLATE_DEFINE(HAVE_MACH_VM, "$have_mach_vm",
  [Define if your system has a working vm_allocate()-based memory allocator.])

fi dnl HAVE_MACH_VM

dnl Various checks if the system supports mmap() and the like functions.
dnl ... and Mach memory allocators are not supported
have_mmap_vm=no
if [[ "x$ac_cv_func_mmap" = "xyes" -a "x$ac_cv_func_munmap" = "xyes" -a \
      "x$ac_cv_func_mprotect" = "xyes" ]]; then
  if [[ "x$have_mach_vm" = "xno" ]]; then
    have_mmap_vm=yes
  fi
fi
AC_TRANSLATE_DEFINE(HAVE_MMAP_VM, "$have_mmap_vm",
  [Define if your system has a working mmap()-based memory allocator.])

dnl Check that mmap() and associated functions work.
if [[ "x$have_mmap_vm" = "xyes" ]]; then

dnl Check if we have a working anonymous mmap()
AC_CACHE_CHECK([whether mmap supports MAP_ANON],
  ac_cv_mmap_anon, [
  AC_LANG_SAVE
  AC_LANG_CPLUSPLUS
  AC_TRY_RUN([
    #define HAVE_MMAP_ANON
    #define CONFIGURE_TEST_VM_MAP
    #define TEST_VM_MMAP_ANON
    #include "vm_alloc.cpp"
  ], ac_cv_mmap_anon=yes, ac_cv_mmap_anon=no,
  dnl When cross-compiling, do not assume anything.
  ac_cv_mmap_anon="guessing no"
  )
  AC_LANG_RESTORE
  ]
)
AC_TRANSLATE_DEFINE(HAVE_MMAP_ANON, "$ac_cv_mmap_anon",
  [Define if <sys/mman.h> defines MAP_ANON and mmap()'ing with MAP_ANON works.])

AC_CACHE_CHECK([whether mmap supports MAP_ANONYMOUS],
  ac_cv_mmap_anonymous, [
  AC_LANG_SAVE
  AC_LANG_CPLUSPLUS
  AC_TRY_RUN([
    #define HAVE_MMAP_ANONYMOUS
    #define CONFIGURE_TEST_VM_MAP
    #define TEST_VM_MMAP_ANON
    #include "vm_alloc.cpp"
  ], ac_cv_mmap_anonymous=yes, ac_cv_mmap_anonymous=no,
  dnl When cross-compiling, do not assume anything.
  ac_cv_mmap_anonymous="guessing no"
  )
  AC_LANG_RESTORE
  ]
)
AC_TRANSLATE_DEFINE(HAVE_MMAP_ANONYMOUS, "$ac_cv_mmap_anonymous",
  [Define if <sys/mman.h> defines MAP_ANONYMOUS and mmap()'ing with MAP_ANONYMOUS works.])

AC_CACHE_CHECK([whether mprotect works],
  ac_cv_mprotect_works, [
  AC_LANG_SAVE
  AC_LANG_CPLUSPLUS
  ac_cv_mprotect_works=yes
  dnl First the tests that should segfault
  for test_def in NONE_READ NONE_WRITE READ_WRITE; do
    AC_TRY_RUN([
      #define CONFIGURE_TEST_VM_MAP
      #define TEST_VM_PROT_$test_def
      #include "vm_alloc.cpp"
    ], ac_cv_mprotect_works=no, rm -f core,
    dnl When cross-compiling, do not assume anything
    ac_cv_mprotect_works="guessing no"
    )
  done
  AC_TRY_RUN([
    #define CONFIGURE_TEST_VM_MAP
    #define TEST_VM_PROT_RDWR_WRITE
    #include "vm_alloc.cpp"
  ], , ac_cv_mprotect_works=no,
  dnl When cross-compiling, do not assume anything
  ac_cv_mprotect_works="guessing no"
  )
  AC_LANG_RESTORE
  ]
)

dnl Remove support for mmap() if mprotect() does not work
if [[ "x$have_mmap_vm" = "xyes" ]]; then
  case $ac_cv_mprotect_works in
    *yes) have_mmap_vm=yes;;
    *no) have_mmap_vm=no;;
  esac
fi
AC_TRANSLATE_DEFINE(HAVE_MMAP_VM, $have_mmap_vm,
  [Define if your system has a working mmap()-based memory allocator.])

fi dnl HAVE_MMAP_VM

dnl Check if we can modify the __PAGEZERO segment for use as Low Memory
AC_CACHE_CHECK([whether __PAGEZERO can be Low Memory area 0x0000-0x3000],
  ac_cv_pagezero_hack, [
  ac_cv_pagezero_hack=no 
  if AC_TRY_COMMAND([Darwin/testlmem.sh 0x3000]); then
    ac_cv_pagezero_hack=yes
    dnl might as well skip the test for mmap-able low memory
    ac_cv_can_map_lm=no
  fi
])
AC_TRANSLATE_DEFINE(PAGEZERO_HACK, "$ac_cv_pagezero_hack",
  [Define if the __PAGEZERO Mach-O Low Memory Globals hack works on this system.])

dnl Check if we can mmap 0x3000 bytes from 0x0000
AC_CACHE_CHECK([whether we can map Low Memory area 0x0000-0x3000],
  ac_cv_can_map_lm, [
  AC_LANG_SAVE
  AC_LANG_CPLUSPLUS
  AC_TRY_RUN([
    #include "vm_alloc.cpp"
    int main(void) { /* returns 0 if we could map the lowmem globals */
      volatile char * lm = 0;
      if (vm_init() < 0) exit(1);
      if (vm_acquire_fixed(0, 0x2000) < 0) exit(1);
      lm[0] = 'z';
      if (vm_release((char *)lm, 0x2000) < 0) exit(1);
      vm_exit(); exit(0);
    }
  ], ac_cv_can_map_lm=yes, ac_cv_can_map_lm=no,
  dnl When cross-compiling, do not assume anything.
  ac_cv_can_map_lm="guessing no"
  )
  AC_LANG_RESTORE
  ]
)

dnl Check signal handlers need to be reinstalled
AC_CACHE_CHECK([whether signal handlers need to be reinstalled],
  ac_cv_signal_need_reinstall, [
  AC_LANG_SAVE
  AC_LANG_CPLUSPLUS
  AC_TRY_RUN([
    #include <stdlib.h>
    #ifdef HAVE_UNISTD_H
    #include <unistd.h>
    #endif
    #include <signal.h>
    static int handled_signal = 0;
    RETSIGTYPE sigusr1_handler(int) { handled_signal++; }
    int main(void) { /* returns 0 if signals need not to be reinstalled */
      signal(SIGUSR1, sigusr1_handler); raise(SIGUSR1); raise(SIGUSR1);
      exit(handled_signal == 2);
    }
  ], ac_cv_signal_need_reinstall=yes, ac_cv_signal_need_reinstall=no,
  dnl When cross-compiling, do not assume anything.
  ac_cv_signal_need_reinstall="guessing yes"
  )
  AC_LANG_RESTORE
  ]
)
AC_TRANSLATE_DEFINE(SIGNAL_NEED_REINSTALL, "$ac_cv_signal_need_reinstall",
  [Define if your system requires signals to be reinstalled.])

dnl Check if sigaction handlers need to be reinstalled
AC_CACHE_CHECK([whether sigaction handlers need to be reinstalled],
  ac_cv_sigaction_need_reinstall, [
  AC_LANG_SAVE
  AC_LANG_CPLUSPLUS
  AC_TRY_RUN([
    #include <stdlib.h>
    #ifdef HAVE_UNISTD_H
    #include <unistd.h>
    #endif
    #include <signal.h>
    static int handled_signal = 0;
    RETSIGTYPE sigusr1_handler(int) { handled_signal++; }
    typedef RETSIGTYPE (*signal_handler)(int);
    static signal_handler mysignal(int sig, signal_handler handler) {
      struct sigaction old_sa;
      struct sigaction new_sa;
      new_sa.sa_handler = handler;
      return ((sigaction(sig,&new_sa,&old_sa) < 0) ? SIG_IGN : old_sa.sa_handler);
    }
    int main(void) { /* returns 0 if signals need not to be reinstalled */
      mysignal(SIGUSR1, sigusr1_handler); raise(SIGUSR1); raise(SIGUSR1);
      exit(handled_signal == 2);
    }
  ], ac_cv_sigaction_need_reinstall=yes, ac_cv_sigaction_need_reinstall=no,
  dnl When cross-compiling, do not assume anything.
  ac_cv_sigaction_need_reinstall="guessing yes"
  )
  AC_LANG_RESTORE
  ]
)
AC_TRANSLATE_DEFINE(SIGACTION_NEED_REINSTALL, "$ac_cv_sigaction_need_reinstall",
  [Define if your system requires sigactions to be reinstalled.])

dnl Check if Mach exceptions supported.
AC_CACHE_CHECK([whether your system supports Mach exceptions],
  ac_cv_have_mach_exceptions, [
  AC_LANG_SAVE
  AC_LANG_CPLUSPLUS
  AC_TRY_RUN([
    #define HAVE_MACH_EXCEPTIONS 1
    #define CONFIGURE_TEST_SIGSEGV_RECOVERY
    #include "vm_alloc.cpp"
    #include "sigsegv.cpp"
  ],
  ac_cv_have_mach_exceptions=yes,
  ac_cv_have_mach_exceptions=no,
  dnl When cross-compiling, do not assume anything.
  ac_cv_have_mach_exceptions=no
  )
  AC_LANG_RESTORE
  ]
)
if [[ "$ac_cv_have_mach_exceptions" = "yes" ]]; then
  sigsegv_recovery=mach
fi
AC_TRANSLATE_DEFINE(HAVE_MACH_EXCEPTIONS, "$ac_cv_have_mach_exceptions",
  [Define if your system supports Mach exceptions.])

dnl Otherwise, check if extended signals are supported.
if [[ -z "$sigsegv_recovery" ]]; then
  AC_CACHE_CHECK([whether your system supports extended signal handlers],
    ac_cv_have_extended_signals, [
    AC_LANG_SAVE
    AC_LANG_CPLUSPLUS
    AC_TRY_RUN([
      #define HAVE_SIGINFO_T 1
      #define CONFIGURE_TEST_SIGSEGV_RECOVERY
      #include "vm_alloc.cpp"
      #include "sigsegv.cpp"
    ],
    ac_cv_have_extended_signals=yes,
    ac_cv_have_extended_signals=no,
    dnl When cross-compiling, do not assume anything.
    ac_cv_have_extended_signals=no
    )
    AC_LANG_RESTORE
    ]
  )
  if [[ "$ac_cv_have_extended_signals" = "yes" ]]; then
    sigsegv_recovery=siginfo
  fi
  AC_TRANSLATE_DEFINE(HAVE_SIGINFO_T, "$ac_cv_have_extended_signals",
    [Define if your system support extended signals.])
fi

dnl Otherwise, check for subterfuges.
if [[ -z "$sigsegv_recovery" ]]; then
  AC_CACHE_CHECK([whether we then have a subterfuge for your system],
  ac_cv_have_sigcontext_hack, [
    AC_LANG_SAVE
    AC_LANG_CPLUSPLUS
    AC_TRY_RUN([
      #define HAVE_SIGCONTEXT_SUBTERFUGE 1
      #define CONFIGURE_TEST_SIGSEGV_RECOVERY
      #include "vm_alloc.cpp"
      #include "sigsegv.cpp"
    ],
    ac_cv_have_sigcontext_hack=yes,
    ac_cv_have_sigcontext_hack=no,
    dnl When cross-compiling, do not assume anything.
    ac_cv_have_sigcontext_hack=no
    )
    AC_LANG_RESTORE
  ])
  if [[ "$ac_cv_have_sigcontext_hack" = "yes" ]]; then
    sigsegv_recovery=sigcontext
  fi
  AC_TRANSLATE_DEFINE(HAVE_SIGCONTEXT_SUBTERFUGE, "$ac_cv_have_sigcontext_hack",
    [Define if we know a hack to replace siginfo_t->si_addr member.])
fi

dnl Check if we can ignore the fault (instruction skipping in SIGSEGV handler)
AC_CACHE_CHECK([whether we can skip instruction in SIGSEGV handler],
  ac_cv_have_skip_instruction, [
  AC_LANG_SAVE
  AC_LANG_CPLUSPLUS
  AC_TRY_RUN([
    #define HAVE_SIGSEGV_SKIP_INSTRUCTION 1
    #define CONFIGURE_TEST_SIGSEGV_RECOVERY
    #include "vm_alloc.cpp"
    #include "sigsegv.cpp"
  ], ac_cv_have_skip_instruction=yes, ac_cv_have_skip_instruction=no,
  dnl When cross-compiling, do not assume anything.
  ac_cv_have_skip_instruction=no
  )
  AC_LANG_RESTORE
  ]
)
AC_TRANSLATE_DEFINE(HAVE_SIGSEGV_SKIP_INSTRUCTION, "$ac_cv_have_skip_instruction",
  [Define if we can ignore the fault (instruction skipping in SIGSEGV handler).])

dnl Can we do Video on SEGV Signals ?
CAN_VOSF=no
if [[ -n "$sigsegv_recovery" ]]; then
  CAN_VOSF=yes
  case $target_os in
  darwin*)
    dnl Signal handlers in darwin are way too slow since the whole
    dnl machine state (GPRs, FPRs, VRs) is forcibly saved.
    dnl In other words, VOSF is slower than static window refreshes.
    CAN_VOSF=no
    ;;
  esac
fi

dnl Enable VOSF screen updates with this feature is requested and feasible
if [[ "x$WANT_VOSF" = "xyes" -a "x$CAN_VOSF" = "xyes" ]]; then
    AC_DEFINE(ENABLE_VOSF, 1, [Define if using video enabled on SEGV signals.])
else
    WANT_VOSF=no
fi

dnl Platform specific binary postprocessor
AC_PATH_PROG(BLESS, "true")
if [[ "x$ac_cv_pagezero_hack" = "xyes" ]]; then
  BLESS=Darwin/lowmem
  LDFLAGS="$LDFLAGS -pagezero_size 0x3000"
fi

dnl Check for GCC 2.7 or higher.
HAVE_GCC27=no
AC_MSG_CHECKING(for GCC 2.7 or higher)
AC_EGREP_CPP(xyes,
[#if __GNUC__ - 1 > 1 || __GNUC_MINOR__ - 1 > 5
  xyes
#endif
], [AC_MSG_RESULT(yes); HAVE_GCC27=yes], AC_MSG_RESULT(no))

dnl Check for GCC 3.0 or higher.
HAVE_GCC30=no
AC_MSG_CHECKING(for GCC 3.0 or higher)
AC_EGREP_CPP(xyes,
[#if __GNUC__ >= 3
  xyes
#endif
], [AC_MSG_RESULT(yes); HAVE_GCC30=yes], AC_MSG_RESULT(no))

dnl Check for ICC.
AC_MSG_CHECKING(for ICC)
HAVE_ICC=no
if $CXX -V -v 2>&1 | grep -q "Intel(R) C++ Compiler"; then
  HAVE_ICC=yes
fi
AC_MSG_RESULT($HAVE_ICC)

# Test if the compiler can generate ELF objects
AC_CACHE_CHECK([whether the compiler can generate ELF objects],
  ac_cv_elf_objects, [
  echo 'int i;' > conftest.$ac_ext
  ac_cv_elf_objects=no
  if AC_TRY_EVAL(ac_compile); then
    case `/usr/bin/file conftest.$ac_objext` in
    *"ELF"*)
      ac_cv_elf_objects=yes
      ;;
    esac
  fi
  rm -rf conftest*
])
ELF_OBJECTS=$ac_cv_elf_objects

dnl CPU emulator sources
if [[ "x$EMULATED_PPC" = "xyes" ]]; then
  CPUSRCS="\
    ../kpx_cpu/src/cpu/ppc/ppc-cpu.cpp \
    ../kpx_cpu/src/cpu/ppc/ppc-decode.cpp \
    ../kpx_cpu/src/cpu/ppc/ppc-execute.cpp \
    ../kpx_cpu/src/cpu/ppc/ppc-translate.cpp"
  CPPFLAGS="$CPPFLAGS -I../kpx_cpu/include -I../kpx_cpu/src"

  dnl Enable JIT compiler, if possible
  if [[ "x$WANT_JIT" = "xyes" ]]; then
    AC_CACHE_CHECK([whether dyngen can be used],
      ac_cv_use_dyngen, [
      case $host_cpu:$ELF_OBJECTS in
      powerpc:yes)
        ac_cv_use_dyngen=yes
        ;;
      x86_64:yes)
        ac_cv_use_dyngen=yes
        ;;
      i?86:yes)
        ac_cv_use_dyngen=yes
        ;;
      *:*)
        ac_cv_use_dyngen=no
        ;;
      esac
      dnl Check for a suitable synthetic opcodes compiler (icc is faking itself as gcc 3.2.2)
      if [[ -z "$DYNGEN_CC" ]]; then
        if [[ "x$HAVE_GCC27" = "xyes" -a "x$HAVE_ICC" = "xno" ]]; then
          DYNGEN_CC=$CXX
        else
          for p in /usr/bin /usr/local/bin; do
            gxx="$p/g++"
            if [[ -x "$gxx" ]]; then
              DYNGEN_CC="$gxx"
            fi
          done
        fi
      fi
      if [[ -z "$DYNGEN_CC" ]] || ! { echo '#include <limits>' | $DYNGEN_CC -xc++ -c -o /dev/null - >& /dev/null; }; then
        ac_cv_use_dyngen=no
      fi
    ])
    if [[ "x$ac_cv_use_dyngen" = "xyes" ]]; then
      case $host_cpu in
      i?86)
        DYNGEN_OP_FLAGS="-fomit-frame-pointer -mpreferred-stack-boundary=2"
        if [[ "x$HAVE_GCC30" = "xyes" ]]; then
          DYNGEN_OP_FLAGS="$DYNGEN_OP_FLAGS -falign-functions=0"
        else
          DYNGEN_OP_FLAGS="$DYNGEN_OP_FLAGS -malign-functions=0"
        fi
        saved_CPPFLAGS=$CPPFLAGS
        CPPFLAGS="$CPPFLAGS -mmmx"
        AC_CHECK_HEADERS(mmintrin.h,  [DYNGEN_OP_FLAGS="$DYNGEN_OP_FLAGS -mmmx"])
        CPPFLAGS="$CPPFLAGS -msse"
        AC_CHECK_HEADERS(xmmintrin.h, [DYNGEN_OP_FLAGS="$DYNGEN_OP_FLAGS -msse"])
        CPPFLAGS="$CPPFLAGS -msse2"
        AC_CHECK_HEADERS(emmintrin.h, [DYNGEN_OP_FLAGS="$DYNGEN_OP_FLAGS -msse2"])
        CPPFLAGS=$saved_CPPFLAGS
        ;;
      x86_64)
        AC_CHECK_HEADERS(mmintrin.h xmmintrin.h emmintrin.h)
        ;;
      esac
      DYNGEN_OP_FLAGS="$DYNGEN_OP_FLAGS -finline-limit=10000"
      if [[ "x$HAVE_GCC30" = "xyes" ]]; then
        DYNGEN_OP_FLAGS="$DYNGEN_OP_FLAGS -fno-reorder-blocks -fno-optimize-sibling-calls"
      fi
    else
      WANT_JIT=no
    fi
    AC_TRANSLATE_DEFINE(ENABLE_DYNGEN, $ac_cv_use_dyngen, [Define to enable dyngen engine])
    if [[ "x$WANT_JIT" = "xyes" ]]; then
      DYNGENSRCS="\
        ../kpx_cpu/src/cpu/jit/dyngen.c \
        ../kpx_cpu/src/cpu/jit/cxxdemangle.cpp"
      CPUSRCS="\
        ../kpx_cpu/src/cpu/jit/jit-cache.cpp \
        ../kpx_cpu/src/cpu/jit/basic-dyngen.cpp \
        ../kpx_cpu/src/cpu/ppc/ppc-dyngen.cpp $CPUSRCS"
    fi
  fi
  CPUSRCS="$CPUSRCS ../kpx_cpu/sheepshaver_glue.cpp"
else
  WANT_JIT=no
fi
if [[ "x$ac_cv_use_dyngen" = "xyes" ]]; then
  AC_CACHE_CHECK([whether static data regions are executable],
    ac_cv_have_static_data_exec, [
    AC_TRY_RUN([int main(void) {
#if defined(__powerpc__)
      static unsigned int p[8] = {0x4e800020,};
      asm volatile("dcbst 0,%0" : : "r" (p) : "memory");
      asm volatile("sync" : : : "memory");
      asm volatile("icbi 0,%0" : : "r" (p) : "memory");
      asm volatile("sync" : : : "memory");
      asm volatile("isync" : : : "memory");
      ((void (*)(void))p)();
      return 0;
#endif
      return 1;
    }], ac_cv_have_static_data_exec=yes, ac_cv_have_static_data_exec=no,
    dnl When cross-compiling, do not assume anything.
    ac_cv_have_static_data_exec=no
    )
  ])
fi
AC_TRANSLATE_DEFINE(HAVE_STATIC_DATA_EXEC, "$ac_cv_have_static_data_exec",
  [Define if your system marks static data pages as executable.])

if [[ "x$WANT_JIT" = "xyes" ]]; then
  CPPFLAGS="$CPPFLAGS -DUSE_JIT"
fi

dnl Generate Makefile.
AC_SUBST(DYNGENSRCS)
AC_SUBST(DYNGEN_CC)
AC_SUBST(DYNGEN_OP_FLAGS)
AC_SUBST(SYSSRCS)
AC_SUBST(CPUSRCS)
AC_SUBST(BLESS)
AC_OUTPUT(Makefile)

dnl Print summary.
echo
echo SheepShaver configuration summary:
echo
echo SDL support ...................... : $SDL_SUPPORT
echo XFree86 DGA support .............. : $WANT_XF86_DGA
echo XFree86 VidMode support .......... : $WANT_XF86_VIDMODE
echo Using PowerPC emulator ........... : $EMULATED_PPC
echo Enable JIT compiler .............. : $WANT_JIT
echo Enable video on SEGV signals ..... : $WANT_VOSF
echo ESD sound support ................ : $WANT_ESD
echo GTK user interface ............... : $WANT_GTK
echo mon debugger support ............. : $WANT_MON
echo Bad memory access recovery type .. : $sigsegv_recovery
echo
echo "Configuration done. Now type \"make\"."
